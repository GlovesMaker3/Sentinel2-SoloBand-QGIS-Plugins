# -*- coding: utf-8 -*-
"""
/***************************************************************************
 SentinelOpenDialog
                                 A QGIS plugin
 Sentinel2 SoloBand is an advanced plugin designed to facilitate the convenient and precise retrieval of individual channels from the Sentinel-2 mission.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2023-08-19
        git sha              : $Format:%H$
        copyright            : (C) 2023 by FishFounder
        email                : buchar123@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from sentinelsat import SentinelAPI
from sentinelsat import SentinelAPI, read_geojson, geojson_to_wkt, make_path_filter
from datetime import date, timedelta
#, read_geojson, geojson_to_wkt, make_path_filter
#, read_geojson, geojson_to_wkt, make_path_filter
# from datetime import date, timedelta
# from collections import OrderedDict
# import boto3
from qgis.core import QgsProject, QgsGeometry, QgsWkbTypes
from shapely.geometry import mapping
from shapely.ops import unary_union
from qgis.utils import iface
from qgis.PyQt.QtCore import QVariant
from qgis.PyQt.QtCore import QVariant
from qgis.core import QgsFeature, QgsGeometry, QgsVectorLayer, QgsWkbTypes
from PyQt5.QtCore import QDate
from PyQt5.QtWidgets import QMainWindow, QFileDialog, QToolButton, QApplication

import os
import subprocess
import sys
import ctypes

from osgeo import ogr
from osgeo import ogr, osr

import osr
from osgeo import ogr
from qgis.core import QgsVectorLayer, QgsProject

from osgeo import ogr, osr
from PyQt5.QtWidgets import QMainWindow, QMessageBox


# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'sentinel_open_dialog_base.ui'))


class SentinelOpenDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(SentinelOpenDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.q1.setText(r'https://scihub.copernicus.eu/dhus')
        self.q2.textChanged.connect(self.login)
        self.q3.setEchoMode(QtWidgets.QLineEdit.Password)
        self.pb4.clicked.connect(self.handle_pb4_click)  # Użyj nowej metody
        self.pb4_clicked = False  # Flaga dla śledzenia kliknięcia pb4

        #zmienna globalna
        self.api = None



        #wybieraj z listy z mapy
        self.cblista.currentIndexChanged.connect(self.wybieraniewarstwzmapy)
        self.populateLayerComboBox()

        #flaga dla przycisku pobierz
        self.pb5.clicked.connect(self.handle_pb5_click)  # Użyj nowej metody
        self.pb5_clicked = False  # Flaga dla śledzenia kliknięcia pb5

        #self.q7.textChanged.connect(self.download)
        self.q7.setText(r"C:\Users\FBI\Downloads\s2")


        # Inicjalizacja interfejsu użytkownika, dodanie przycisku, itp.


        self.path.clicked.connect(self.choose_directory)
        self.path_1.clicked.connect(self.choose_directory_1)

        # Inicjalizacja zmiennej output_dir
        self.output_dir = ""

        self.logged_in = False

        # Dictionary mapping bands to filenames
        self.band_filenames = {
            'AOT_10m': ['AOT_10m.jp2'],
            'B02_10m': ['B02_10m.jp2'],
            'B03_10m': ['B03_10m.jp2'],
            'B04_10m': ['B04_10m.jp2'],
            'B08_10m': ['B08_10m.jp2'],
            'TCI_10m': ['TCI_10m.jp2'],
            'WVP_10m': ['WVP_10m.jp2'],
            'AOT_20m': ['AOT_20m.jp2'],
            'B01_20m': ['B01_20m.jp2'],
            'B02_20m': ['B02_20m.jp2'],
            'B03_20m': ['B03_20m.jp2'],
            'B04_20m': ['B04_20m.jp2'],
            'B05_20m': ['B05_20m.jp2'],
            'B06_20m': ['B06_20m.jp2'],
            'B07_20m': ['B07_20m.jp2'],
            'B8A_20m': ['B8A_20m.jp2'],
            'B11_20m': ['B11_20m.jp2'],
            'B12_20m': ['B12_20m.jp2'],
            'SCL_20m': ['SCL_20m.jp2'],
            'TCI_20m': ['TCI_20m.jp2'],
            'WVP_20m': ['WVP_20m.jp2']
        }



        self.down_active = False

        self.folder_opened = False
        self.process = None





    def choose_directory(self):
        dialog = QFileDialog(self)
        dialog.setFileMode(QFileDialog.Directory)

        selected_dir = dialog.getExistingDirectory(self)


        if selected_dir:
            self.output_dir = selected_dir
            self.q7.setText(self.output_dir)  # Ustawienie ścieżki jako tekst przycisku
            print("Wybrany katalog:", self.output_dir)

    # Dodaje wszystkie warstwy z mapy do listy
    def populateLayerComboBox(self):
        print('populateLayerComboBox(self)')
        # Clear the combobox
        self.cblista.clear()

        # Get a list of map layers from the QgsProject
        layers = QgsProject.instance().mapLayers().values()

        #__ Bylo - kazda warstwa na liscie cb
        # # Add layer names to the combobox
        # for layer in layers:
        #     self.cblista.addItem(layer.name())

        # __ bylo - tylko shp i geojson
        # Add layer names to the combobox only if they are SHP or GeoJSON
        for layer in layers:
            if layer.source().lower().endswith('.shp') or layer.source().lower().endswith('.geojson'):
                self.cblista.addItem(layer.name())

        # # __ JEST -  geojson
        # # Add layer names to the combobox only if they are SHP or GeoJSON
        # for layer in layers:
        #     if layer.source().lower().endswith('.geojson'):
        #         self.cblista.addItem(layer.name())

    # def wybieraniewarstwzmapy(self):
    #     selected_layer_name = self.cblista.currentText()  # Get the name of the selected layer
    #     print(f'Wybrana warstwa: {selected_layer_name}')

# # WYBIERANIE Z LISTY ROZWIJALNEJ
#     def wybieraniewarstwzmapy(self, index):
#         print('wybieraniewarstwzmapy(self, index):')
#         selected_layer_name = self.cblista.currentText()  # Get the name of the selected layer
#         print(f'Wybrana warstwa: {selected_layer_name}')
#         if selected_layer_name:
#             if selected_layer_name.lower().endswith('.shp'):
#                 self.process_shp_to_geojson(selected_layer_name)
#                 print('WYBIERANIE Z LISTY ROZWIJALNEJ- if *shp')
#             else:
#                 self.process_geojson(selected_layer_name)
#                 print('WYBIERANIE Z LISTY ROZWIJALNEJ - else')


# # WYBIERANIE Z LISTY ROZWIJALNEJ
#     def wybieraniewarstwzmapy(self, index):
#         print('wybieraniewarstwzmapy(self, index):')
#         selected_layer_name = self.cblista.currentText()  # Get the name of the selected layer
#         print(f'Wybrana warstwa: {selected_layer_name}')
#
#         self.process_shp_to_geojson()




#otwiera plik do shp



    def wybieraniewarstwzmapy(self, index):
        print('wybieraniewarstwzmapy(self, index):')
        selected_layer_name = self.cblista.currentText()  # Get the name of the selected layer
        print(f'Wybrana warstwa: {selected_layer_name}')

        # Zakładam, że selected_layer_name zawiera pełną ścieżkę do pliku SHP



        #
        # shp_file_dialog = QFileDialog()
        # shp_file_dialog.setNameFilter("Shapefile (*.shp)")
        # shp_file_dialog.setFileMode(QFileDialog.ExistingFile)
        #
        # if shp_file_dialog.exec_():
        #     selected_layer_name = shp_file_dialog.selectedFiles()[0]
        #     print(f'Wybrana warstwa: {selected_layer_name}')
        #
        #     self.process_shp_to_geojson(selected_layer_name)
        # else:
        #     print("Anulowano wybieranie pliku SHP")



# otwiera plik do shp ale inne bilbioteki os



    # def wybieraniewarstwzmapy(self, index):
    #     print('wybieraniewarstwzmapy(self, index):')
    #
    #     shp_file_dialog = QFileDialog()
    #     shp_file_dialog.setNameFilter("Shapefile (*.shp)")
    #     shp_file_dialog.setFileMode(QFileDialog.ExistingFile)
    #
    #     if shp_file_dialog.exec_():
    #         selected_layer_name = shp_file_dialog.selectedFiles()[0]
    #         print(f'Wybrana warstwa: {selected_layer_name}')
    #
    #         # Sprawdź, czy rozszerzenie pliku to ".shp"
    #         _, file_extension = os.path.splitext(selected_layer_name)
    #         if file_extension.lower() == '.shp':
    #             print(f'Prawidłowa warstwa: {selected_layer_name}')
    #             self.process_shp_to_geojson(selected_layer_name)
    #         else:
    #             print("Wybrany plik nie jest plikiem SHP")
    #     else:
    #         print("Anulowano wybieranie pliku SHP")



    def process_shp_to_geojson_lista(self, shp_path):
        shp_driver = ogr.GetDriverByName('ESRI Shapefile')
        shp_dataset = shp_driver.Open(shp_path)

        if shp_dataset:
            shp_layer = shp_dataset.GetLayer()
            shp_spatial_ref = shp_layer.GetSpatialRef()

            # Sprawdź, czy warstwa nie jest już w WGS84
            if shp_spatial_ref and shp_spatial_ref.GetAttrValue("AUTHORITY", 1) != "4326":
                wgs84_spatial_ref = osr.SpatialReference()
                wgs84_spatial_ref.ImportFromEPSG(4326)  # Kod EPSG dla WGS84
                coord_transform = osr.CoordinateTransformation(shp_spatial_ref, wgs84_spatial_ref)
            else:
                coord_transform = None

            geojson_driver = ogr.GetDriverByName('GeoJSON')

            index = 1
            while True:
                output_geojson_path = shp_path.replace('.shp', f'_{index}.geojson')
                if not os.path.exists(output_geojson_path):
                    break
                index += 1

            geojson_dataset = geojson_driver.CreateDataSource(output_geojson_path)
            geojson_layer = geojson_dataset.CreateLayer('', srs=wgs84_spatial_ref, geom_type=ogr.wkbPolygon)

            for feature in shp_layer:
                geom = feature.GetGeometryRef()
                if coord_transform:
                    geom.Transform(coord_transform)

                new_feature = ogr.Feature(geojson_layer.GetLayerDefn())
                new_feature.SetGeometry(geom.Clone())
                geojson_layer.CreateFeature(new_feature)
                new_feature = None

            geojson_dataset = None
            shp_dataset = None

            print("Plik SHP przekonwertowany na GeoJSON:", output_geojson_path)
            QtWidgets.QMessageBox.warning(self, 'Uwaga', f'Plik SHP przekonwertowany na GeoJSON: {output_geojson_path}')
            # Wczytaj nową warstwę GeoJSON do QGIS
            new_layer = QgsVectorLayer(output_geojson_path, f"New_GeoJSON_{index}", "ogr")

            if new_layer.isValid():
                QgsProject.instance().addMapLayer(new_layer)
                self.cblista.addItem(new_layer.name())  # Dodaj nową warstwę do comboboxa
                print("Nowa warstwa dodana do QGIS:", new_layer.name())
            else:
                print("Nie udało się wczytać nowej warstwy do QGIS 123.")

        else:
            print("Nie udało się otworzyć pliku SHP.")


#WYBIERANIE DLA 3 KROPECZEK
    def choose_directory_1(self):
        dialog = QFileDialog(self)
        dialog.setFileMode(QFileDialog.ExistingFile)
        dialog.setNameFilter("Shapefiles (*.shp);;GeoJSON files (*.geojson)")

        selected_file, _ = dialog.getOpenFileName(self)

        if selected_file:
            if selected_file.lower().endswith('.shp'):
                self.process_shp_to_geojson(selected_file)
            else:
                self.process_geojson(selected_file)



#konwersja SHP NA GEOJSON


    def process_shp_to_geojson(self, shp_path):
        shp_driver = ogr.GetDriverByName('ESRI Shapefile')
        shp_dataset = shp_driver.Open(shp_path)


        if shp_dataset:
            shp_layer = shp_dataset.GetLayer()
            shp_spatial_ref = shp_layer.GetSpatialRef()

            # Sprawdź, czy warstwa nie jest już w WGS84
            if shp_spatial_ref and shp_spatial_ref.GetAttrValue("AUTHORITY", 1) != "4326":
                wgs84_spatial_ref = osr.SpatialReference()
                wgs84_spatial_ref.ImportFromEPSG(4326)  # Kod EPSG dla WGS84
                coord_transform = osr.CoordinateTransformation(shp_spatial_ref, wgs84_spatial_ref)
            else:
                coord_transform = None

            geojson_driver = ogr.GetDriverByName('GeoJSON')

            index = 1
            while True:
                output_geojson_path = shp_path.replace('.shp', f'_{index}.geojson')
                if not os.path.exists(output_geojson_path):
                    break
                index += 1

            geojson_dataset = geojson_driver.CreateDataSource(output_geojson_path)
            geojson_layer = geojson_dataset.CreateLayer('', srs=wgs84_spatial_ref, geom_type=ogr.wkbPolygon)

            for feature in shp_layer:
                geom = feature.GetGeometryRef()
                if coord_transform:
                    geom.Transform(coord_transform)

                new_feature = ogr.Feature(geojson_layer.GetLayerDefn())
                new_feature.SetGeometry(geom.Clone())
                geojson_layer.CreateFeature(new_feature)
                new_feature = None

            geojson_dataset = None
            shp_dataset = None

            print("Plik SHP przekonwertowany na GeoJSON:", output_geojson_path)
            QtWidgets.QMessageBox.warning(self, 'Uwaga', f'Plik SHP przekonwertowany na GeoJSON: {output_geojson_path}')
            # Wczytaj nową warstwę GeoJSON do QGIS
            new_layer = QgsVectorLayer(output_geojson_path, f"New_GeoJSON_{index}", "ogr")

            if new_layer.isValid():
                QgsProject.instance().addMapLayer(new_layer)
                self.cblista.addItem(new_layer.name())  # Dodaj nową warstwę do comboboxa
                print("Nowa warstwa dodana do QGIS:", new_layer.name())
            else:
                print("Nie udało się wczytać nowej warstwy do QGIS 123.")

        else:
            print("Nie udało się otworzyć pliku SHP.")



    def process_geojson(self, geojson_path):
        # Wczytaj nową warstwę GeoJSON do QGIS
        new_layer = QgsVectorLayer(geojson_path, self.get_file_name(geojson_path), "ogr")

        if new_layer.isValid():
            QgsProject.instance().addMapLayer(new_layer)
            self.cblista.addItem(new_layer.name())  # Dodaj nową warstwę do comboboxa


            # Display a message indicating the user needs to log in
            QtWidgets.QMessageBox.warning(self, 'Uwaga', f'Nowa warstwa GeoJSON dodana do QGIS: {new_layer.name()}')

            print("Nowa warstwa GeoJSON dodana do QGIS:", new_layer.name())
        else:
            print("Nie udało się wczytać nowej warstwy GeoJSON do QGIS.")

    # def get_file_name(self, file_path):
    #     return os.path.splitext(os.path.basename(file_path))[0]




    def handle_pb4_click(self):
        self.pb4_clicked = True
        self.login()

    def login(self):
        print('login(self)')
        value1 = self.q1.text()
        value2 = self.q2.text()
        value3 = self.q3.text()

        if value1:
        #if value1 and value2 and value3 and self.pb4_clicked:
            self.logged_in = True
            print(f'url: {value1}')
            print(f'Login: {value2}')
            print(f'Password: {value3}')



            #api = SentinelAPI(value2, value3, value1)
            #api = SentinelAPI('GlovesMaker123', 'd63613255D', 'https://scihub.copernicus.eu/dhus')
            self.q4.setText('Zostałeś zalogowany')
            # Tworzenie komunikatu
            # message_box = QtWidgets.QMessageBox()
            # message_box.setWindowTitle('Zalogowano')
            # message_box.setIcon(QtWidgets.QMessageBox.Information)
            # message_box.setText('Zostałeś zalogowany.')
            # message_box.setStandardButtons(QtWidgets.QMessageBox.Ok)
            # message_box.exec_()
        self.api = SentinelAPI('GlovesMaker123', 'd63613255D', 'https://scihub.copernicus.eu/dhus')
        #self.api = SentinelAPI('fishfounder', 'LifeBelowWather1123', 'https://scihub.copernicus.eu/dhus')
        print('ok_25_08_2023')


            ################################# Search and download ########################################





    # def wybieraniewarstwzmapy(self, index):
    #     selected_layer_name = self.cblista.currentText()  # Get the name of the selected layer
    #
    #     if selected_layer_name.lower().endswith('.shp'):
    #         print(f'Selected layer: {selected_layer_name} (SHP file)')
    #         QtWidgets.QMessageBox.warning(self, 'Attention',
    #                                       f'WARNING: The program works only with *GeoJSON format. Selected layer: {selected_layer_name} (not a GeoJSON file - you can load a *Shp file alongside)')
    #     else:
    #         print(f'Selected layer: {selected_layer_name}')


    def handle_pb5_click(self):
        print('handle_pb5_click(self):')
        #self.pb5_clicked = True
        self.download()


    def download_band(self, s3, output_dir):
        print('download_band(self, s3, output_dir):')
        n = 0
        for x in s3:
            n += 1
            print('_2_: ' + str(n))
            path_filter = make_path_filter("*{}".format(x))
            print(path_filter)
            self.api.download_all(self.products, directory_path=output_dir, nodefilter=path_filter)

            print('\n')
            print("Download for - *{}".format(x))
            self.Status_pobierania.setText("Download for - *{}".format(x))






    def download(self):
        print('download(self)')
        if not self.logged_in:
            # Display a message indicating the user needs to log in
            QtWidgets.QMessageBox.warning(self, 'Attention', 'Log in before downloading.')
            return



        # selected_layer_name = self.cblista.currentText()
        # layer = QgsProject.instance().mapLayersByName(selected_layer_name)[0]


        selected_layer_name = self.cblista.currentText()
        layer = QgsProject.instance().mapLayersByName(selected_layer_name)[0]

        if layer.geometryType() != QgsWkbTypes.PolygonGeometry:
            print('Only in GeoJSON format from map. The selected layer does not contain polygons. Choose a layer with polygons.')
            QtWidgets.QMessageBox.warning(self, 'Attention', f'1 WARNING: Only in GeoJSON format from map. The selected layer does not contain polygons. Choose a layer with polygons. (not a GeoJSON file - you can load a *Shp file alongside)')

            return

        if layer.featureCount() == 0:
            print('Only in GeoJSON format from map')
            QtWidgets.QMessageBox.warning(self, 'Attention', f'2 WARNING: Only in GeoJSON format from map. The selected layer does not contain polygons. Choose a layer with polygons. (not a GeoJSON file - you can load a *Shp file alongside)')

            return

        feature = next(layer.getFeatures())
        footprint_wkt = feature.geometry().asWkt()




        # # Definicja przedziału dat
        # # start_date = date.today() - timedelta(days=5)
        start_date = self.da1.date().toPyDate()
        # # end_date = date.today()
        end_date = self.da2.date().toPyDate()
        print('okej')
        # # Wyszukaj produkty Sentinel-2 odpowiadające zdefiniowanym kryteriom
        products_0 = self.api.query(footprint_wkt,
                               date=(start_date, end_date),
                               platformname='Sentinel-2',
                               producttype='S2MSI2A',
                               cloudcoverpercentage=(0, self.cloud.value()))
        #
        # # # Wybierz jeden produkt z pobranych
        # product_id = list(products_0.keys())
        # print(product_id)
        # print(f'cloud {self.cloud.value()}')
        #
        #
        #
        #
        # z = 0
        # for k, v in products_0.items():
        #
        #
        #     # print(k)
        #     # print(v)

        #     self.products = self.api.query(footprint_wkt,
        #                          date=(start_date, end_date),
        #                          platformname='Sentinel-2',
        #                          producttype='S2MSI2A',
        #                          cloudcoverpercentage=(0, self.cloud.value()),
        #                          filename='{}'.format(v['filename']))

        # Pobranie listy identyfikatorów produktów z kluczy słownika products_0
        identyfikatory_produktow = list(products_0.keys())
        print(identyfikatory_produktow)
        print(len(identyfikatory_produktow))
        # Changing the message:
        QtWidgets.QMessageBox.warning(self, 'Attention', f'WARNING: {len(identyfikatory_produktow)} satellite scene(s) have been located for the selected spectral band.')
        # Iteracja przez wszystkie produkty w products_0
        for identyfikator_produktu in identyfikatory_produktow:
            informacje_o_produkcie = products_0[identyfikator_produktu]

            # Wydobycie potrzebnych informacji o produkcie
            print('\n')
            print('\n')
            print('\n')
            print('Teraz będę pobierać: ' + informacje_o_produkcie['title'])
            QtWidgets.QMessageBox.warning(self, 'Attention', "Now I will download. Please click 'OK' and wait for the program to start downloading the image. Even if there's no immediate response, please wait patiently.")


            #z += 1
            #print('Przejście - for nr 1: ' + str(z))

            # Pobranie produktów na podstawie informacji o produkcie
            self.products = self.api.query(footprint_wkt,
                                           date=(start_date, end_date),
                                           platformname='Sentinel-2',
                                           producttype='S2MSI2A',
                                           cloudcoverpercentage=(0, self.cloud.value()),
                                           filename='{}'.format(informacje_o_produkcie['filename']))





###################### 10m ##############################



            if self.ALL_10m.isChecked():

                s3 = ['AOT_10m.jp2', 'B02_10m.jp2', 'B03_10m.jp2', 'B04_10m.jp2', 'B08_10m.jp2', 'TCI_10m.jp2', 'WVP_10m.jp2']

                print('ALL_10m')
            elif self.ALL_20m.isChecked():
                s3 = ['AOT_20m.jp2', 'B01_20m.jp2', 'B02_20m.jp2', 'B03_20m.jp2', 'B04_20m.jp2', 'B05_20m.jp2', 'B06_20m.jp2', 'B07_20m.jp2', 'B8A_20m.jp2', 'B11_20m.jp2', 'B12_20m.jp2', 'SCL_20m.jp2', 'TCI_20m.jp2', 'WVP_20m.jp2']
                print('ALL_20m')


            else:
                selected_bands = [band for band in self.band_filenames if getattr(self, band).isChecked()]
                print('Band: '+str(selected_bands))


                #komunikat o tym, że zaczyna się pobieranie
                # if not self.down_active:
                #     # komunikat o pobierainu danych
                #     QtWidgets.QMessageBox.warning(self, 'Download', 'Please waiting....')
                #     #return

                if not selected_bands:
                    print('Nie wybrano żadnych kanałów do pobrania.')
                    QtWidgets.QMessageBox.warning(self, 'Attention', 'The band for download have not been selected.')

                    return

                s3 = []
                for band in selected_bands:
                    s3.extend(self.band_filenames.get(band, []))
                    #print(s3[:])


            if not s3:
                print('Brak plików do pobrania.')
                return

            print(s3[:])


            output_dir = self.q7.text()

            # self.open_file(output_dir)

            self.download_band(s3, output_dir)


        # Resetowanie listy s3 dla kolejnego produktu
        s3 = []



